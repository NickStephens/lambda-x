module LambdaCore

import Lambda
import LamParsec

--booleans
tr = La.Lb.a;
fl = La.Lb.b;

--
iF = Lp.La.Lb.p a b;
oR  = Lp.Lq.p p q;
anD = Lp.Lq.p q p;
noT = Lm.La.Lb.m b a;

--list functions
empty   = #fl;
isEmpty = Ll.l (La.Lb.#fl) #tr;
cons = Lh.Lt.Lc.Ln.c h (t c n);
hd   = Ll.l #tr #fl;
tl   = Ll.#frst (l (La.Lb.#pr (#scnd b) (#cons a (#scnd b))) (#pr #empty #empty));
--append
ap   = Lf.La.Lb.#iF (#isEmpty a) b (#cons (#hd a) (f (#tl a) b));
apnd = La.Lb.#y #ap a b;
--qsort 
qsy   = Lf.Las.#iF (#isEmpty as) #empty (#apnd (#apnd (f (#les (#hd as) (#tl as))) (#cons (#hd as) #empty)) (f (#gts (#hd as) (#tl as))));
qsort = Las.#y #qsy as;
lesy = Lf.La.Las.#iF (#isEmpty as) #empty (#iF (#lte (#hd as) a) (#cons (#hd as) (f a (#tl as))) (f a (#tl as)));
les  = La.Las.#y #lesy a as;
gtsy = Lf.La.Las.#iF (#isEmpty as) #empty (#iF (#gt (#hd as) a) (#cons (#hd as) (f a (#tl as))) (f a (#tl as)));
gts  = La.Las.#y #gtsy a as;

--pairList functions car is head cdr is tail
car  = Lp.p #tr;
cdr  = Lp.p #fl;
nil  = Lx.#tr;
nul  = Lp.p (Lx.Ly.#fl);

papp  = #y (Lg.La.Lb.#nul a b (#pr (#car a) (g (#cdr a) b)));
plen  = #y (Lg.Lc.Lx.#nul x c (g (#sucs c) (#cdr x))) #zero;
pidx  = Lx.Li. #car (i #cdr x);
plast = #y (Lg.Lx.#nul x #nil (#nul (#cdr x) (#car x) (g (#cdr x))));
prvr  = #y (Lg.La.Ll.#nul l a (g (#pr (#car l) a) (#cdr l))) #nil;
pfold = Lf.Le.Lx.#y (Lg.Ly.#nul y e (f (#car y) (g (#cdr y)))) x;

pqsy   = Lf.Las.#iF (#nul as) #nil (#papp (f (#ples (#car as) (#cdr as))) (#papp (#pr (#car as) #nil) (f (#gts (#car as) (#cdr as)))));
pqsort = Las.#y #pqsy as;
plesy = Lf.La.Las.#iF (#nul as) #nil (#iF (#lte (#car as) a) (#pr (#car as) (f a (#cdr as))) (f a (#cdr as)));
ples  = La.Las.#y #plesy a as;
pgtsy = Lf.La.Las.#iF (#nul as) #nil (#iF (#gt (#car as) a) (#pr (#car as) (f a (#cdr as))) (f a (#cdr as)));
pgts  = La.Las.#y #pgtsy a as;

ins    = #y (Lf.La.Las.#iF (#oR (#nul as) (#lte a (#car as))) (#pr a as) (#pr (#car as) (f a (#cdr as))));
insort = #y (Lf.Las.Lbs.#iF (#nul as) bs (f (#cdr as) (#ins (#car as) bs)));
insert = Ll.#pfold #ins #nil l;

--pair functions pr is also cons for pairList
pr   = Lx.Ly.Lp.p x y;
frst = Lp.p #tr;
scnd = Lp.p #fl;


--Y combinator
y = Lg.(Lx.g (x x)) (Lx.g (x x));

--some church numerals
zero  = Lf.Lx.x;
one   = Lf.Lx.f x;
two   = Lf.Lx.f (f x);
three = Lf.Lx.f (f (f x));
four  = Lf.Lx.f (f (f (f x)));
five  = Lf.Lx.f (f (f (f (f x))));

--church numeral operations
sucs  = Ln.Lf.Lx.f (n f x);
prdc  = Ln.Lf.Lx.n (Lg.Lh.h (g f)) (Lu.x) (Lu.u);
isZr = Ln.n (Lx.#fl) #tr;
subt = Lm.Ln.n #prdc m;
plus = Lm.Ln.Lf.Lx.m f (n f x);
mult = Lm.Ln.Lf.m (n f);
exp  = Lm.Ln.n m;
lte  = Lm.Ln.#isZr (#subt m n);
eq   = Lm.Ln.#anD (#lte m n) (#lte n m);
gt   = Lm.Ln.#noT (#lte m n);

--casE matches a pattern to a list of pattern value pairs and returns a value
casE = Li.Lp.#y #cs i p;
cs   = Lf.Li.Lp.#iF (#eq (#frst (#hd p)) i) (#scnd (#hd p)) (f i (#tl p));

--test stuff
ptrn  = #pr #zero #tr;
ptrni = #pr #one #fl;
lst   = #cons #ptrn (#cons #ptrni #empty);
test  = #casE #zero #lst;
tst   = La.Lb.Lc.Ld.Le.a b c d e;
alist = #cons #one (#cons #two #empty);
blist = #cons #three (#cons #four #empty);
qlist = #cons #three (#cons #one (#cons #zero (#cons #four #empty)));
qtest = Las.(#apnd (#apnd ( (#les (#hd as) (#tl as))) (#cons (#hd as) #empty)) ( (#gts (#hd as) (#tl as))));
plista = #pr #zero (#pr #one (#pr #two #nil));
plistb = #pr #three (#pr #four #nil);
pqlist = #pr #three (#pr #one (#pr #zero (#pr #four (#pr #zero (#pr #three (#pr #two (#pr #one (#pr #two #nil))))))));
pless = Las.(#ples (#car as) (#cdr as));
pgtss = Las.(#pgts (#car as) (#cdr as));
ppen = Las.Lb.Lscs.#papp as (#papp (#pr b #nil) scs);
sing = #pr #one #nil;
tet = #pr #one (#pr #two (#pr #three (#pr five (#pr #four #nil))));
tat = #pr #four (#pr #three (#pr #two (#pr #one #nil)));
tot = #pr #zero (#pr #one (#pr #three (#pr #four #nil)));

mane = #insort #pqlist #nil;
man  = #insert #pqlist;
